Given a binary tree, find its minimum depth.
http://www.geeksforgeeks.org/find-minimum-depth-of-a-binary-tree/

The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

思路:
The idea is to traverse the given Binary Tree. For every node, check if it is a leaf node. If yes, then return 1. If not leaf node then if left subtree is NULL, then recur for right subtree. And if right subtree is NULL, then recur for left subtree. If both left and right subtrees are NULL, then take the minimum of two heights.

class Solution {
public:
// recursion,时间复杂度:O(n)
    int minDepth(TreeNode *root) {
        if (root == NULL) return 0;
        if (root->left == NULL && root->right == NULL) return 1;
        if (root->left == NULL) {
            return 1 + minDepth(root->right);
        }
        if (root->right == NULL) {
            return 1 + minDepth(root->left);
        }
        return 1 + min(minDepth(root->left), minDepth(root->right));
    }
};

The above method may end up with complete traversal of Binary Tree even when the topmost leaf is close to root. 
上述方法需要将这棵二叉树完全遍历一遍,即使当最上面的叶子结点非常靠近root结点时
A Better Solution is to do Level Order Traversal. While doing traversal, returns depth of the first encountered leaf node. 
用level order traversal, 返回第一个遇到的叶子结点的高度

class Solution { 对的，非常好理解,用level order traversal,
public:
//level order traversal
    int minDepth(TreeNode *root) {
        if (!root) {
            return 0;
        }
        queue<TreeNode *> q;
        q.push(root);
        q.push(NULL);  //'NULL' mark the end of one level
        int depth = 1;
        while (!q.empty()) {
            TreeNode *node = q.front();
            q.pop();
            if (node == NULL) {
                depth++;
                q.push(NULL);
            } else {   //If it is the first leaf node seen so far, it's depth is minimum
                if (node->left == NULL && node->right == NULL) {
                    return depth;
                }
                if (node->left) {
                    q.push(node->left);
                }
                if (node->right) {
                    q.push(node->right);
                }
            }
        }
    }
};

class Solution { 也是用level order traversal,非常好的代码
public:
// 和print all nodes in a certain level 非常相似,只不过那里的level是从0开始
    int minDepth(TreeNode *root) {
        if (root == NULL) {
            return 0;
        }
        queue<pair<TreeNode *, int>> q;
        q.push(make_pair(root, 1)); // Enqueue Root and initialize depth as 1
        while (!q.empty()) {
            auto top = q.front();
            q.pop();
            
            TreeNode *node = top.first;
            int depth = top.second;
            
            if (node->left == NULL && node->right == NULL) {
                return depth; //If it is the first leaf node seen so far,
            }                      // then it's depth is minimum
            if (node->left) {
                q.push(make_pair(node->left, depth + 1));
            }
            if (node->right) {
                q.push(make_pair(node->right, depth + 1));
            }
        }
    }
};


class Solution { 也是对的,不过没有上面2个好理解
public:
// recursion + queue
    int minDepth(TreeNode *root) {
        if (root == NULL) return 0;
        queue<TreeNode *> q;
        q.push(root);
        TreeNode *rightmost = root;
        int depth = 1;
        while (!q.empty()) {
            TreeNode *node = q.front();
            q.pop();
            if (node->left == NULL && node->right == NULL) return depth;
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
            if (node == rightmost) {
                depth++;
                rightmost = node->right ? node->right : node->left;
            }
        }
    }
};
