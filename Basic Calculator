Basic Calculator 

Implement a basic calculator to evaluate a simple expression string.

The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .

You may assume that the given expression is always valid.

Some examples:
"1 + 1" = 2
" 2-1 + 2 " = 3
"(1+(4+5+2)-3)+(6+8)" = 23
Note: Do not use the eval built-in library function.

class Solution {
public:
    int calculate(string s) {
        stack<int> stk;
        int res = 0;
        int sign = 1;
        for (int i = 0; i < s.size(); ++i) {
            char c = s[i];
            if (c >= '0' && c <= '9') {
                int cur = c - '0';
                while (i + 1 < s.size() && s[i+1] >= '0' && s[i+1] <= '9') {
                    cur = cur * 10 + (s[++i] - '0');
                }
                res += sign * cur;
            } else if (c == '-') {
                sign = -1;
            } else if (c == '+') {
                sign = 1;
            } else if (c == '(') {
                stk.push(res);  //将'('之前的值res放到栈里
                res = 0;        //清零，用于下一次的数值计算
                stk.push(sign); //将'('之前的符号sign放到栈里
                sign = 1;
            } else if (c == ')') {
                res = stk.top() * res;  //此时的栈顶是'('之前的sign
                stk.pop();
                res += stk.top();   //此时的栈顶是'('之前的res
                stk.pop();
                sign = 1;
            }
        }
        return res;
    }
};
/*
遇到 '(' 就把之前的结果和符号push进stack. 遇到')'就把 当前结果*stack中的符号 再加上stack中之前的结果. 
http://blog.csdn.net/xudli/article/details/46554835
*/

https://leetcode.com/discuss/53921/16-ms-solution-in-c-with-stacks
改写成2个栈，和上面的写法基本一样的：
class Solution {
public:
    int calculate(string s) {
        stack<int> nums;
    	stack<int> op;
    	int cur = 0, res = 0, sign = 1;
    	for (char c : s) {
    		if (c >= '0' && c <= '9') {
    			cur = cur * 10 + c - '0';
    		} else {
    			res += sign * cur;
    			cur = 0;
    			if (c == '+') sign = 1;
    			if (c == '-') sign = -1;
    			if (c == '(') {
    				nums.push(res); //将'('之前的值res放到栈nums里
    				op.push(sign);   //将'('之前的符号sign放到栈op里
    				res = 0;     //清零，用于下一次的数值计算
    				sign = 1;
    			}
    			if (c == ')' && op.size()) {
    				res = op.top() * res + nums.top();  //此时的栈op的栈顶是'('之前的sign,此时的栈nums的栈顶是'('之前的res
    				op.pop();
    				nums.pop();
    				sign = 1;
    			}
    		}
    	}
    	res += sign * cur;
    	return res;
    }
};

递归写法：好像没有stack写法好理解
class Solution {
public:
    int calculate(string s) {
        int pos = 0;
        return evaluate(s, pos);
    }
private:
    int evaluate(string& s, int &i) {
        int res = 0, sign = 1;
        while (i < s.size() && s[i] != ')') {
            if (s[i] == '+' || s[i] == ' ') {
                i++;
            } else if (s[i] == '-') {
                i++;
                sign = -1;
            } else if (s[i] == '(') {
                i++;
                res += (sign == 1 ? evaluate(s, i) : -evaluate(s, i));
                sign = 1;
            } else {  //numeric chars
                int num = 0;
                while (i < s.size() && s[i] >= '0' && s[i] <= '9') {
                    num = num * 10 + s[i++] - '0';
                }
                res += (sign == 1) ? num : -num;
                sign = 1;
            }
        }
        i++;  //skip the current ')'
        return res;
    }
};
/*
Each invocation of evaluate() evaluates whatever inside a pair of parenthese. Nested parenthese will be handled by recursive calls.

So "(1+(4+5+2)-3)+(6+8)"

-> (1+(9+2)-3)+(6+8)

-> (1+11-3)+(6+8)

-> (12-3)+(6+8)

-> 9+(6+8)

-> 9+14

-> 23

https://leetcode.com/discuss/50048/24-line-c-o-n-recursive-solution-20ms-and-intuitive
*/
