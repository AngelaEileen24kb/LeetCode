3Sum Smaller
http://www.cnblogs.com/jcliBlogger/p/4736809.html

Problem Description:

Given an array of n integers nums and a target, find the number of index triplets i, j, k with 0 <= i < j < k < n that satisfy the condition nums[i] + nums[j] + nums[k] < target.

For example, given nums = [-2, 0, 1, 3], and target = 2.

Return 2. Because there are two triplets which sums are less than 2:

[-2, 0, 1]
[-2, 0, 3]
Follow up:
Could you solve it in O(n^2) runtime?

Sort nums first and then fix the left index (i) at each time while adjusting the middle and right indexes (j, k). The following code should be self-explanatory.

O(n^2) c++ solution

class Solution {
public:
	int threeSumSmaller(vector<int>& nums, int target) {
		if (nums.size() < 3) return 0;
		sort(nums.begin(), nums.end());
		int n = nums.size(), res = 0;
		for (int i = 0; i < n - 2; ++i) {
			int j = i + 1, k = n - 1;
			while (j < k) {
				if (nums[i] + nums[j] + nums[k] >= target) {
					k--;
				} else {
					res += k - j;
					j++;
				}
			}
		}
		return res;
	}
};

或者这么写，都一样的：
https://leetcode.com/discuss/52442/o-n-2-c-solution

int threeSumSmaller(vector<int>& nums, int target) {
	if (nums.size() < 3) return 0;
	sort(nums.begin(), nums.end());
	int n = nums.size(), count = 0;
	for (int i = 0; i < n - 2; ++i) {
		if (nums[i] + nums[i+1] + nums[i+2] >= target) {
			break;
		}
		int j = i + 1, k = n - 1;
		while (j < k) {
			while (j < k && nums[i] + nums[j] + nums[k] >= target) {
				k--;
			}
			count += k - j;
			j++;
		}
	}
	return count;
}
