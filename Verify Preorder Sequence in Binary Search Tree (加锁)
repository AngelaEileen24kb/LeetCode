Verify Preorder Sequence in Binary Search Tree
https://leetcode.com/discuss/51543/java-o-n-and-o-1-extra-space

Solution 1

Kinda simulate the traversal, keeping a stack of nodes (just their values) of which we're still in the left subtree. If the next number is smaller than the last stack value, then we're still in the left subtree of all stack nodes, so just push the new one onto the stack. But before that, pop all smaller ancestor values, as we must now be in their right subtrees (or even further, in the right subtree of an ancestor). Also, use the popped values as a lower bound, since being in their right subtree means we must never come across a smaller number anymore.

bool verifyPreorder(vector<int> preorder) {
	int low = INT_MIN;
	stack<int> stk;
	for (int p : preorder) {
		if (p < low) {          //If we find a node who is on right side
			return false;   //and smaller than root, return false
		}
		while (!stk.empty() && p > stk.top()) {
			low = stk.top();
			stk.pop();
		}
		stk.push(p);
	}
	return true;
}

Solution 2 ... O(1) extra space

Same as above, but abusing the given array for the stack.

bool verifyPreorder(vector<int>& preorder) {
	int low = INT_MIN, i = -1;
	for (int p : preorder) {
		if (p < low) {
			return false;
		}
		while (i >= 0 && p > preorder[i]) {
			low = preorder[i];
			i--;
		}
		preorder[++i] = p;
	}
	return true;
}

Discuss:
Hi, Stefan. Nice codes, as your usual style :-) A little question, I wonder if it is possible to solve this problem in also O(1) additional space but without modifying preorder?

I'm not sure about O(1) extra space without modifying preorder, but I think it's impossible. As someone recently pointed out, that only works for regular languages, and this problem's language doesn't seem regular to me. Let's use each number as a character (i.e., ignoring that the alphabet should be finite) and use the Myhill–Nerode theorem. Consider the words xi = [3i, 3i+1] for all integers i. Now for words xi != xj, the extension [3*min(i,j)+2] distinguishes them. For example, you can append [5] to [3,4] but not to [6,7]. So there are infinitely many pairwise distinguishable words, thus infinitely many equivalence classes, and thus the language isn't regular.

Not sure I did this fully properly, though :-)

Hi Stefan,

The solution will also return true for both inorder traversal and postorder traversal in the same BST. For example, in the following BST:

          6
        /   \
      2     7
     / \   
    1   3

The algorithm will return true for all three tree traversals.

Sorry, I don't get your point. Partly because that's rather a property of the problem, not so much a property of a solution. Though you're wrong about postorder. For example, the postorder of

1
  \
    3
   /
  2
is [2, 3, 1], which isn't a valid preorder. For inorder you're correct, every valid inorder is also a valid preorder.

Hi Stefan,

Thanks for the reply. You are right, I believe this is a property of the problem but not the solution. The solution is very succinct and correct, sorry that I didn't make it clear!

geeksforgeeks上有详细的解答过程:如下:
http://www.geeksforgeeks.org/check-if-a-given-array-can-represent-preorder-traversal-of-binary-search-tree/

Check if a given array can represent Preorder Traversal of Binary Search Tree

Given an array of numbers, return true if given array can represent preorder traversal of a Binary Search Tree, else return false. Expected time complexity is O(n).


A Simple Solution is to do following for every node pre[i] starting from first one.

1) Find the first greater value on right side of current node. 
   Let the index of this node be j. Return true if following 
   conditions hold. Else return false
    (i)  All values after the above found greater value are 
         greater than current node.
    (ii) Recursive calls for the subarrays pre[i+1..j-1] and 
         pre[j+1..n-1] also return true. 
Time Complexity of the above solution is O(n^2)

An Efficient Solution can solve this problem in O(n) time. The idea is to use a stack. This problem is similar to Next (or closest) Greater Element problem. Here we find next greater element and after finding next greater, if we find a smaller element, then return false.
思路:
1) Create an empty stack.
2) Initialize root as INT_MIN.
3) Do following for every element pre[i]
     a) If pre[i] is smaller than current root, return false.
     b) Keep removing elements from stack while pre[i] is greater
        then stack top. Make the last removed item as new root (to
        be compared next).
        At this point, pre[i] is greater than the removed root
        (That is why if we see a smaller element in step a), we 
        return false)
     c) push pre[i] to stack (All elements in stack are in decreasing
        order) 

bool canRrepresentBST(vector<int> &pre) {
    int n = pre.size();
    stack<int> stk;
    int root = INT_MIN;
    for (int i = 0; i < n; ++i) {
        if (pre[i] < root) {  // If we find a node who is on right side
            return false;      // and smaller than root, return false
        }
        while (!stk.empty() && stk.top() < pre[i]) { 
            root = stk.top();  //If pre[i] is in right subtree of stack top,  
            stk.pop();         //Keep removing items smaller than pre[i] 
        }                      //and make the last removed item as new root
        stk.push(pre[i]);  //At this point either stack is empty or 
    }                      //pre[i] is smaller than root, push pre[i]

}
