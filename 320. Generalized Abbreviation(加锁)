[LeetCode] Generalized Abbreviation 通用简写
 

Write a function to generate the generalized abbreviations of a word.

Example:

Given word = "word", return the following list (order does not matter):

["word", "1ord", "w1rd", "wo1d", "wor1", "2rd", "w2d", "wo2", "1o1d", "1or1", "w1r1", "1o2", "2r1", "3d", "w3", "4"]
 

这道题让我们对一个单词进行部分简写，简写的规则是若干个字母可以用数字来表示，但是不能有两个相邻的数字，具体可以参考题目中给的例子，
根据我以往的经验，这种列举所有情况的必定是要用DFS来写的，但是我一时半会又没想到该咋递归，后来我数了一下题目中给的例子的所有情况的个数，
是16个，而word有4个字母，刚好是2的4次方，这是巧合吗，当然不是，后来我又发现如果把0到15的二进制写出来，每一个可以对应一种情况，如下所示：

0000 word
0001 wor1
0010 wo1d
0011 wo2
0100 w1rd
0101 w1r1
0110 w2d
0111 w3
1000 1ord
1001 1or1
1010 1o1d
1011 1o2
1100 2rd
1101 2r1
1110 3d
1111 4



那么我们就可以观察出规律，凡是0的地方都是原来的字母，单独的1还是1，如果是若干个1连在一起的话，就要求出1的个数，
用这个数字来替换对应的字母，既然规律找出来了，那么代码就很好写了，如下所示：

法1:
class Solution {
public:
    vector<string> generateAbbreviations(string word) {
        vector<string> res;
        for (int i = 0; i < pow(2, word.size()); ++i) {
            string out = "";
            int cnt = 0;
            for (int j = 0; j < word.size(); ++j) {
                if ((i >> j) & 1) ++cnt;
                else {
                    if (cnt != 0) {
                        out += to_string(cnt);
                        cnt = 0;
                    }
                    out += word[j];
                }
            }
            if (cnt > 0) out += to_string(cnt);
            res.push_back(out);
        }
        return res;
    }
};

上述方法返回结果的顺序为：

["word","1ord","w1rd","2rd","wo1d","1o1d","w2d","3d","wor1","1or1","w1r1","2r1","wo2","1o2","w3","4"]

那么迭代的写法看完了，来考虑一些递归的写法吧，上网搜了一下，发现下面三种写法比较容易理解，
 

法2:
class Solution {
public:
    vector<string> generateAbbreviations(string word) {
        vector<string> res{word};
        helper(word, 0, res);
        return res;
    }
    void helper(string word, int pos, vector<string> &res) {
        for (int i = pos; i < word.size(); ++i) {
            for (int j = 1; i + j <= word.size(); ++j) {
                string t = word.substr(0, i);
                t += to_string(j) + word.substr(i + j);
                res.push_back(t);
                helper(t, i + 1 + to_string(j).size(), res);
            }
        }
    }
};

上述方法返回结果的顺序为：

["word","1ord","1o1d","1o2","1or1","2rd","2r1","3d","4","w1rd","w1r1","w2d","w3","wo1d","wo2","wor1"]

法3:
class Solution {
public:
    vector<string> generateAbbreviations(string word) {
        vector<string> res;
        helper(word, 0, 0, "", res);
        return res;
    }
    void helper(string word, int pos, int cnt, string out, vector<string> &res) {
        if (pos == word.size()) {
            if (cnt > 0) out += to_string(cnt);
            res.push_back(out);
        } else {
            helper(word, pos + 1, cnt + 1, out, res);
            helper(word, pos + 1, 0, out + (cnt > 0 ? to_string(cnt) : "") + word[pos], res);
        }
    }
};

上述方法返回结果的顺序为：

 ["4","3d","2r1","2rd","1o2","1o1d","1or1","1ord","w3","w2d","w1r1","w1rd","wo2","wo1d","wor1","word"]

法3:
class Solution {
public:
    vector<string> generateAbbreviations(string word) {
        vector<string> res;
        res.push_back(word.size() == 0 ? "" : to_string(word.size()));
        for (int i = 0; i < word.size(); ++i) {
            for (auto a : generateAbbreviations(word.substr(i + 1))) {
                string left = i > 0 ? to_string(i) : "";
                res.push_back(left + word.substr(i, 1) + a);
            }
        }
        return res;
    }
};

上述方法返回结果的顺序为：

["4","w3","wo2","wor1","word","wo1d","w1r1","w1rd","w2d","1o2","1or1","1ord","1o1d","2r1","2rd","3d"]

在Xcode上debug得到的过程:

class Solution {
public:
    vector<string> generateAbbreviations(string word) {
        vector<string> res;
        for (int i = 0; i < pow(2, word.size()); ++i) {
            string out = "";
            int cnt = 0;
            for (int j = 0; j < word.size(); ++j) {
                if ((i >> j) & 1) ++cnt;
                else {
                    if (cnt != 0) {
                        out += to_string(cnt);
                        cnt = 0;
                    }
                    out += word[j];
                }
            }
            if (cnt > 0) out += to_string(cnt);
            res.push_back(out);
        }
        return res;
    }
};

int main(int argc, const char* argv[]) {
    Solution s;
    string word = "word";
    vector<string> res = s.generateAbbreviations(word);
    for(auto x : res) {
        cout << x << '\n';
    }
}

/*
上述方法返回结果的顺序为：

["word","1ord","w1rd","2rd","wo1d","1o1d","w2d","3d","wor1","1or1","w1r1","2r1","wo2","1o2","w3","4"]

0000  word 
0001  1ord
0010  w1rd
0011  2rd
0100  wo1d
0101  1o1d
0110  w2d
0111  3d
1000  wor1
1001  1or1
1010  w1r1
1011  2r1
1100  wo2
1101  1o2
1110  w3
1111  4
*/


那么迭代的写法看完了，来考虑一些递归的写法吧，上网搜了一下，发现下面三种写法比较容易理解， 

解法三:
class Solution {
public:
    vector<string> generateAbbreviations(string word) {
        vector<string> res{word};
        helper(word, 0, res);
        return res;
    }
    void helper(string word, int pos, vector<string> &res) {
        for (int i = pos; i < word.size(); ++i) {
            for (int j = 1; i + j <= word.size(); ++j) {
                string t = word.substr(0, i);
                t += to_string(j) + word.substr(i + j);
                res.push_back(t);
                helper(t, i + 1 + to_string(j).size(), res);
            }
        }
    }
};

/*
上述方法返回结果的顺序为：

["word","1ord","1o1d","1o2","1or1","2rd","2r1","3d","4","w1rd","w1r1","w2d","w3","wo1d","wo2","wor1"]
开始:          word
i = 0, j = 1,  1ord --> 1o1d, 1o2, 1or1
       j = 2,  2rd --> 2r1
       j = 3,  3d
       j = 4,  4
i = 1, j = 1,  w1rd --> w1r1
	   j = 2,  w2d
	   j = 3,  w3
i = 2, j = 1,  wo1d 
	   j = 2,  wo2
i = 3, j = 1,  wor1
*/

解法4:

class Solution {
public:
    vector<string> generateAbbreviations(string word) {
        vector<string> res;
        helper(word, 0, 0, "", res);
        return res;
    }
    void helper(string word, int pos, int cnt, string out, vector<string> &res) {
        if (pos == word.size()) {
            if (cnt > 0) out += to_string(cnt);
            res.push_back(out);
        } else {
            helper(word, pos + 1, cnt + 1, out, res);
            helper(word, pos + 1, 0, out + (cnt > 0 ? to_string(cnt) : "") + word[pos], res);
        }
    }
};
/*
上述方法返回结果的顺序为：

 ["4","3d","2r1","2rd","1o2","1o1d","1or1","1ord","w3","w2d","w1r1","w1rd","wo2","wo1d","wor1","word"]

4
3d
2r1
2rd
1o2
1o1d
1or1
1ord
w3
w2d
w1r1
w1rd
wo2
wo1d
wor1
word

*/


之前的:


参考：
https://leetcode.com/discuss/75421/my-backtracking-c-solution

class Solution {
public:
    vector<string> generateAbbreviations(string word) {
        vector<string> res;
        helper(word, "", 0, res, false);
        return res;
    }

    void helper(string& word, string abbr, int i, vector<string>& res, bool prevNum) {
        if (i == word.length()) {  //case of when a path is finshed
            res.push_back(abbr);
            return;
        }
			              //every charactor is whether selected or not,
        helper(word, abbr+word[i], i+1, res, false);   // here is selected
		//prevNum true, means previous charactor has been number, here ignored to avoid the case like w11d of word, it should be w2d
		            if (!isnum)
        if (!prevNum) {
            // Add number abbreviations only when we added a character instead of an abbreviation earlier
            for (int len = 1; i+len <= word.length(); ++len) { // iterate all possible length
                helper(word, abbr+to_string(len), i+len, res, true);
            }
        }
    }
};

另一种写法：
参考：
https://leetcode.com/discuss/75754/java-backtracking-solution
思路：
The idea is: for every character, we can keep it or abbreviate it. To keep it, we add it to the current solution and 
carry on backtracking. To abbreviate it, we omit it in the current solution, but increment the count, which indicates 
how many characters have we abbreviated. When we reach the end or need to put a character in the current solution, 
and count is bigger than zero, we add the number into the solution.

vector<string> generateAbbreviations(string word) {
    vector<string> res;
    helper(word, "", 0, res, 0);
    return res;
}
void helper(string& word, string cur, int i, vector<string>& res, int count) {
    if (i == word.length()) {
        if (count > 0) {
            cur += count; // cur += char(count + '0');
        }
        res.push_back(cur);
    } else {
        helper(word, cur, i + 1, res, count + 1);
        helper(word, cur + (count > 0) ? count : "" + word[i], i + 1, res, 0);
    }
}

What is the time complexity of this solution? O(2^n) ?

这个似乎更清晰一点:
分析：
	http://www.cnblogs.com/littletail/p/5208043.html
　　DFS或者BFS，按照规则将字母替换成数字，注意递归条件和参数的正确性

vector<string> generateAbbreviations(string word) {
    vector<string> res;
    dfs(word, res, "", 0, 0);
    return res;
}
void dfs(string& word, vector<string>& res, string cur, int count, int i) {
    if (i == word.length()) {   //Condition for ending
        if (count > 0) {
            cur += char(count + '0');
        }
        res.push_back(cur);
        return;
    } 
    //Stop converting the characters into numbers
    if (count > 0) {
        dfs(word, res, cur + char(count + '0') + word[i], 0, i+1);
    } else {
        dfs(word, res, cur + word[i], 0, i+1);
    }
    //Continue converting ....
    dfs(word, res, cur, count + 1, i+1);
    return;
}


我怎么觉得这种写法也是对的：
https://leetcode.com/discuss/75669/c-dfs-concise-solution

class Solution {
public:
    vector<string> generateAbbreviations(string word) {
        vector<string> res;
        dfs(res, "", word, false);
        return res;
    }
private:
    void dfs(vector<string>& res, string cur, string word, bool isnum) {
        if (word.empty()) {
            res.push_back(cur);
            return;
        } 
        dfs(res, cur + word.substr(0, 1), word.substr(1), false);
        if (cur.empty() || !isnum) {
            for (int i = 1; i <= word.size(); ++i) {
                dfs(res, cur + to_string(i), word.substr(i), true);
            }
        }
    }
};
