323. Number of Connected Components in an Undirected Graph (加锁)

[LeetCode] Number of Connected Components in an Undirected Graph 无向图中的连通区域的个数
 

Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes),
write a function to find the number of connected components in an undirected graph.

Example 1:

     0          3

     |          |

     1 --- 2    4

Given n = 5 and edges = [[0, 1], [1, 2], [3, 4]], return 2.

Example 2:

     0           4

     |           |

     1 --- 2 --- 3

Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]], return 1.

 Note:

You can assume that no duplicate edges will appear in edges. Since all edges are undirected, 
[0, 1] is the same as [1, 0] and thus will not appear together in edges.

 

这道题让我们求无向图中连通区域的个数，LeetCode中关于图Graph的题屈指可数，解法都有类似的特点，
都是要先构建邻接链表Adjacency List来做。这道题的一种解法是利用DFS来做，思路是给每个节点都有个flag标记其是否被访问过，
对于一个未访问过的节点，我们将结果自增1，因为这肯定是一个新的连通区域，然后我们通过邻接链表来遍历与其相邻的节点，
并将他们都标记成已访问过，遍历完所有的连通节点后我们继续寻找下一个未访问过的节点，以此类推直至所有的节点都被访问过了，
那么此时我们也就求出来了连通区域的个数。

Accepted DFS in C++
https://leetcode.com/discuss/77308/accepted-dfs-in-c

http://www.cnblogs.com/grandyang/p/5166356.html

class Solution {
public:
    int countComponents(int n, vector<pair<int, int>>& edges) {
        if (n == 0) return 0;

        vector<vector<int>> graph(n);
        vector<bool> visited(n, false);

        for (auto& edge : edges) { //auto a : edges
            graph[edge.first].push_back(edge.second);
            graph[edge.second].push_back(edge.first);
        }
        int count = 0;
        for (int i = 0; i < n; ++i) {
            if (!visited[i]) {
                count++;
                dfs(i, graph, visited);
            }
        }
        return count;
    }
private:
    void dfs(int i, vector<vector<int>>& graph, vector<bool>& visited) {
        if (visited[i]) return;
        visited[i] = true;
        for (int j = 0; j < graph[i].size(); ++i) {
            dfs(graph[i][j], graph, visited);
        }
    }
};

Union Find Solution:
这道题还有一种比较巧妙的方法，不用建立邻接链表，也不用DFS，思路是建立一个root数组，下标和节点值相同，
此时root[i]表示节点i属于group i，我们初始化了n个部分 (res = n)，假设开始的时候每个节点都属于一个单独的区间，
然后我们开始遍历所有的edge，对于一条边的两个点，他们起始时在root中的值不相同，这时候我们我们将结果减1，表示少了一个区间，
然后更新其中一个节点的root值，使两个节点的root值相同，那么这样我们就能把连通区间的所有节点的root值都标记成相同的值，
不同连通区间的root值不相同，这样也能找出连通区间的个数。

class Solution {
public:
    int countComponents(int n, vector<pair<int, int> >& edges) {
        int res = n;
        vector<int> root(n);
        for (int i = 0; i < n; ++i) root[i] = i;
        for (auto a : edges) {
            int x = find(root, a.first), y = find(root, a.second);
            if (x != y) {
                --res;
                root[y] = x;
            }
        }
        return res;
    }
    int find(vector<int> &root, int i) {
        while (root[i] != i) i = root[i];
        return i;
    }
};


和上面的写法几乎一样，更喜欢上面的写法：
sharing my 256ms C++ solution
https://leetcode.com/discuss/88248/sharing-my-256ms-c-solution

class Solution {
public:
    int  countComponents(int n, vector<pair<int, int>>& edges) {
        vector<vector<int>> graph(n, vector<int>(0));
        vector<bool> visited(n, false);

        int n = edges.size(), first, second;
        for (int i = 0; i < n; ++i) {
            first = edges[i].first;
            second = edges[i].second;
            graph[first].push_back(second);
            graph[second].push_back(first);
        }
        int count = 0;
        for (int i = 0; i < n; ++i) {
            if (!visited[i]) {
                helper(i, graph, visited);
                count++;
            }
        }
        return count;
    }
private:
    void helper(int n, vector<vector<int>>& graph, vector<bool>& visited) {
        if (visited[n]) return;
        else {
            visited[n] = true;
            vector<int> v = graph[n];
            for (int i = 0; i < v.size(); ++i) {
                helper(v[i], graph, visited);
            }
        }
    }
};

类似题目：

Clone Graph

Minimum Height Trees 

Course Schedule

Course Schedule II
