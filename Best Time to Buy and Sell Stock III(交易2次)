Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most two transactions.

Note:
 You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
 Solution: dp. max profit =  max { l2r[0...i] + r2l[i+1...N-1] }.
                         0 <= i <= N-1

//法1:时间:O(N),空间: O(N)
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if (n < 2) {
            return 0;
        }
        int l2r[n], r2l[n];
        l2r[0] = 0;
        r2l[n-1] = 0;
        
        int minv = prices[0];
        for (int i = 1; i < n; i++) {
            minv = min(minv, prices[i]);
            l2r[i] = max(l2r[i-1], prices[i] - minv);
        }
        
        int maxv = prices[n-1];
        for (int i = n - 2; i >= 0; i--) {
            maxv = max(maxv, prices[i]);
            r2l[i] = max(r2l[i+1], maxv - prices[i]);
        }
        
        int res = l2r[n-1];
        for (int i = 0; i < n - 1; i++) {
            res = max(res, l2r[i] + r2l[i+1]);
        }
        return res;
    }
};

//法二：法1:时间:O(N),空间: O(1)
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int buy1 = INT_MIN, buy2 = INT_MIN;//这里buy1和buy2必须是INT_MIN, 不能初始化为0，否则wrong answer
        int sell1 = 0, sell2 = 0;
        for (auto p : prices) {           //assume we have no money at first
            sell2 = max(sell2, buy2 + p); //The maximum profit if we've just sold 2nd stock so far 
            buy2 = max(buy2, sell1 - p);  // The maximum profit if we've just buy 2nd stock so far
            sell1 = max(sell1, buy1 + p); // The maximum profit if we've just sold 1st stock so far
            buy1 = max(buy1, -p);     //The maximum if we've just buy 1st stock so far
        }
        return sell2;  //since sell1 is initiated as 0, so sell2 will always be higher than sell1 
    }
};
/*
time complexity: O(n),n = prices.size();
space complexity: O(1)
*/

和方法1:相同
/*
分析：动态规划法。以第i天为分界线，计算第i天之前进行一次交易的最大收益preProfit[i]，和第i天之后进行一次交易的最大收益postProfit[i]，最后遍历一遍，max{preProfit[i] + postProfit[i]} (0≤i≤n-1)就是最大收益。第i天之前和第i天之后进行一次的最大收益求法同Best Time to Buy and Sell Stock I。
时间O(n)，空间O(n)。
time complexity: O(n),n = prices.size();
space complexity: O(n)

dp. max profit =  max { l2r[0...i] + r2l[i+1...N-1] }.
                         0 <= i <= N-1
*/
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if (n < 2) {
            return 0;
        }
        int pre[n], post[n];
        pre[0] = 0;
        post[n-1] = 0;
        
        int curmin = prices[0];
        for (int i = 1; i < n; i++) {
            curmin = min(curmin, prices[i]);
            pre[i] = max(pre[i-1], prices[i] - curmin);
        }
        
        int curmax = prices[n-1];
        for (int i = n - 2; i >= 0; i--) {
            curmax = max(curmax, prices[i]);
            post[i] = max(post[i+1], curmax - prices[i]);
        }
        
        int res = 0;
        for (int i = 0; i < n; i++) {
            res = max(res, pre[i] + post[i]);
        }
        return res;
    }
};

或者最后一小段代码这样写：
int res = pre[n-1];
for (int i = 0; i < n - 1; i++) {
    res = max(res, pre[i] + post[i+1]);
}



最原始的写法：
class Solution {
public:
    int maxProfit(vector<int> &prices) {
        int N = prices.size();
        if (N <= 1) {
            return 0;
        }
        int l2r[N], r2l[N];
        l2r[0] = 0;
        r2l[N-1] = 0;
        int minv = prices[0];
        for (int i = 1; i < N; i++) {
            minv = min(minv, prices[i]);
            l2r[i] = max(l2r[i-1], prices[i] - minv);
        }
        int maxv = prices[N-1];
        for (int i = N - 2; i >= 0; i--) {
            maxv = max(maxv, prices[i]);
            r2l[i] = max(r2l[i+1], maxv - prices[i]);
        }
        int res = l2r[N-1];
        for (int i = 0; i < N-1; i++) {
            res = max(res, l2r[i] + r2l[i+1]);
        }
        return res;
    }
};
