Best Time to Buy and Sell Stock IV

Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most k transactions.

Note:
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

//法1:
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        if (prices.empty()) {
            return 0;
        }
        if (k >= prices.size()) {
            return maxProfit2(prices);
        }
        
        int global[k+1] = {0};
        int local[k+1] = {0};
        
        for (int i = 0; i < prices.size() - 1; ++i) {
            int diff = prices[i+1] - prices[i];
            for (int j = k; j >= 1; --j) {  //注意这里j是从k减小到1，如果换成j++会出错
                local[j] = max(global[j-1] + max(diff, 0), local[j] + diff);
                global[j] = max(global[j], local[j]); //global和local的位置不能换
            }
        }
        return global[k];
    }
    
    int maxProfit2(vector<int>& prices) {
        int res = 0;
        for (int i = 0; i < prices.size() - 1; ++i) {
            if (prices[i+1] > prices[i]) {
                res += prices[i+1] - prices[i];
            }
        }
        return res;
    }
};

/*
复杂度：时间O(n*k)，空间O(k)
定义global[i][j]为在到达第i天时最多可进行j次交易的最大利润，此为全局最优
定义local[i][j]为在到达第i天时最多可进行j次交易并且最后一次交易在最后一天卖出的最大利润，此为局部最优
golbal[i][j] = max(global[i-1][j], local[i][j]);
local[i][j] = max(global[i-1][j-1] + max(diff, 0), local[i-1][j] + diff);
其中（diff = prices[i] - prices[i-1]）
其中的local[i – 1][j] + diff就是为了避免第i天交易和第i-1天交易合并成一次交易而少一次交易收益

global:也就是取当前局部最好的，和过往全局最好的中大的那个（因为最后一次交易如果包含当前天一定在局部最好的里面，否则一定在过往全局最优的里面）。
local:第一个是全局到i-1天进行j-1次交易，然后加上今天的交易，如果今天是赚钱的话（也就是前面只要j-1次交易，最后一次交易取当前天），第二个量则是取local第i-1天j次交易，然后加上今天的差值（这里因为local[i-1][j]比如包含第i-1天卖出的交易，所以现在变成第i天卖出，并不会增加交易次数，而且这里无论diff是不是大于0都一定要加上，因为否则就不满足local[i][j]必须在最后一天卖出的条件了

分析：
传统的动态规划我们会这样想，到第i天时进行j次交易的最大收益，要么等于到第i-1天时进行j次交易的最大收益（第i天价格低于第i-1天的价格），要么等于到第i-1天时进行j-1次交易，然后第i天进行一次交易（第i天价格高于第i-1天价格时）。于是得到动规方程如下（其中diff = prices[i] – prices[i – 1]）：

profit[i][j] = max(profit[i – 1][j], profit[i – 1][j – 1] + diff)

看起来很有道理，但其实不对，为什么不对呢？因为diff是第i天和第i-1天的差额收益，如果第i-1天当天本身也有交易呢，那么这两次交易就可以合为一次交易，这样profit[i – 1][j – 1] + diff实际上只进行了j-1次交易，而不是最多可以的j次，这样得到的最大收益就小了。

那么怎样计算第i天进行交易的情况的最大收益，才会避免少计算一次交易呢？我们用一个局部最优解和全局最有解表示到第i天进行j次的收益，这就是该动态规划的特殊之处。

http://www.cnblogs.com/grandyang/p/4295761.html
*/

class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        if (prices.empty()) {
            return 0;
        }
        if (k >= prices.size()) {
            return maxProfit2(prices);
        }
        
        vector<int> buy(k+1, INT_MIN); //注意这里两个都是k+1,因为是从后往前
        vector<int> sell(k+1, 0);
        
        for (auto p : prices) {
            for (int i = k; i >= 1; --i) {  //从后往前
                sell[i] = max(sell[i], buy[i] + p);
                buy[i] = max(buy[i],  sell[i-1] - p);  //卖了之后才能买,所以是sell[i-1]
            }
        }
        return sell[k];  //注意返回的是sell[k]
    }
    
    int maxProfit2(vector<int>& prices) {
        int res = 0;
        for (int i = 0; i < prices.size() - 1; ++i) {
            if (prices[i+1] > prices[i]) {
                res += prices[i+1] - prices[i];
            }
        }
        return res;
    }
};
/*
http://m.blog.csdn.net/blog/elton_xiao/44676957
此题思路借鉴之以下leetcode讨论：

https://leetcode.com/discuss/18330/is-it-best-solution-with-o-n-o-1
该讨论是针对交易次数为2次的的情况。

但思路是一样的。我将其扩充到任意次数的情况。

需要注意的事，test case中，有一个非常大的k值，直接会让内存分配失败。

如何处理该种情况呢。 当k值超过prices值的个数时，此时，可以把问题转换为交易数次不限的情况。即

Best Time to Buy and Sell Stock II

另一篇博文也很好的介绍了这个问题的解法。这两者的思路其实是一样的。

参见：http://blog.csdn.net/linhuanmars/article/details/23236995

*/

或者这么写，两种写法是一样的,不过还是上面的比较好理解:
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        if (prices.empty()) {
            return 0;
        }
        if (k >= prices.size()) {
            return maxProfit2(prices);
        }
        
        vector<int> buy(k, INT_MIN); ////注意这里buy大小是k，sell大小是k+1,因为是从前往后
        vector<int> sell(k+1, 0);
        
        for (auto p : prices) {
            for (int i = 0; i < k; ++i) {  //从前往后
                sell[i] = max(sell[i], buy[i] + p);
                buy[i] = max(buy[i],  sell[i+1] - p);  //卖了之后才能买,所以是sell[i+1]
            }
        }
        return sell[0];
    }
    
    int maxProfit2(vector<int>& prices) {
        int res = 0;
        for (int i = 0; i < prices.size() - 1; ++i) {
            if (prices[i+1] > prices[i]) {
                res += prices[i+1] - prices[i];
            }
        }
        return res;
    }
};
