Balanced Binary Tree

Given a binary tree, determine if it is height-balanced.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

https://leetcode.com/discuss/22898/the-bottom-up-o-n-solution-would-be-better

This problem is generally believed to have two solutions: the top down approach and the bottom up way.

1.The first method checks whether the tree is balanced strictly according to the definition of balanced binary tree: the difference between the heights of the two sub trees are not bigger than 1, and both the left sub tree and right sub tree are also balanced. With the helper function depth(), we could easily write the code;

class Solution {
public:
    bool isBalanced(TreeNode* root) {
        if (root == NULL) return true;
        int left = depth(root->left);
        int right = depth(root->right);
        return abs(left - right) <= 1 && isBalanced(root->left) && isBalanced(root->right);
    }
    int depth(TreeNode *node) {
        if (node == NULL) return 0;
        return max(depth(node->left), depth(node->right)) + 1;
    }
};

For the current node root, calling depth() for its left and right children actually has to access all of its children, thus the complexity is O(N). We do this for each node in the tree, so the overall complexity of isBalanced will be O(N^2). This is a top down approach.

Discuss:  https://leetcode.com/discuss/22898/the-bottom-up-o-n-solution-would-be-better

brilliant solution! but I have a question, on the first approach can you explain why we need to check isbalanced(root->left) and isbalanced(root->right) at the end ?

We need to check isBalanced(root -> left) and isBalanced(root -> right) because that's the definition of balancedness: the depth difference between the left and right subtrees is not larger than 1 and both the left and right subtrees are itself balanecd.


Great post. though I would argue that the first approach is O(NlogN)
for each level you are doing a total scan of N, and there are logN levels.

if the tree is skewed binary tree(just a linked list ), the first approach would be O(N^2) so the worst case is O(N^2). Am I right?

Yeah, that's what I have in mind.

下面这个方法更好
2.The second method is based on DFS. Instead of calling depth() explicitly for each child node, we return the height of the current node in DFS recursion. When the sub tree of the current node (inclusive) is balanced, the function dfsHeight() returns a non-negative value as the height. Otherwise -1 is returned. According to the leftHeight and rightHeight of the two children, the parent node could check if the sub tree is balanced, and decides its return value.
Bottom up way:

时间复杂度: O(n), 比 top down 的方法要好
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        return dfsHeight(root) != -1;
    }
    int dfsHeight(TreeNode *root) {
        if (root == NULL) return 0;
        int left = dfsHeight(root->left);
        int right = dfsHeight(root->right);
        if (left == -1 || right == -1) return -1;
        if (abs(left - right) > 1) return -1;
        return max(left, right) + 1;
    }
};

In this bottom up approach, each node in the tree only need to be accessed once. Thus the time complexity is O(N), better than the first solution.




If the tree was skewed, then the first "abs" condition will fail and we wont proceed further for root->left and root->right

I guess you are correct.
