Symmetric Tree
判断二叉树是不是对称的(即自己是不是自己的镜像)
Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).

For example, this binary tree is symmetric:

    1
   / \
  2   2
 / \ / \
3  4 4  3
But the following is not:
    1
   / \
  2   2
   \   \
   3    3

/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
//iterative way
    bool isSymmetric(TreeNode *root) {
        if (root == NULL) return true;
        queue<TreeNode *> q;
        q.push(root->left);
        q.push(root->right);
        while (!q.empty()) {
            TreeNode *t2 = q.front(); q.pop();
            TreeNode *t1 = q.front(); q.pop();
            if (t1 == NULL && t2 == NULL) continue;//这里必须是continue,不能直接return true
            if (t1 == NULL || t2 == NULL) return false;
            if (t1->val != t2->val) return false;
            q.push(t1->left);
            q.push(t2->right);
            q.push(t1->right);
            q.push(t2->left);
        }
        return true;
    }
};
class Solution {
public:
//recursion
    bool isSymmetric(TreeNode *root) {
        if (root == NULL) return true;
        return solve(root->left, root->right);
    }
    bool solve(TreeNode *t1, TreeNode *t2) {
        if (t1 == NULL && t2 == NULL) return true;
        if (t1 == NULL || t2 == NULL) return false;
        if (t1->val != t2->val) return false;
        return solve(t1->left, t2->right) && solve(t1->right, t2->left);
    }
};

求二叉树的镜像
void mirrorRe(TreeNode *node) {
    if (node == NULL || (node->left == NULL && right == NULL)) return;
    TreeNode *tmp = node->left;
    node->left = node->right;
    node->right = tmp;
    if (node->left) {
        mirrorRe(node->left);
    } 
    if (node->right) {
        mirrorRe(node->right);
    }
}
//用辅助栈模拟递归，把树的头结点放入栈，只要栈不为空，弹出栈的栈顶结点，交换它的左右子数，如果它有左子树，就把左子树压入栈，如果它有右子树，就把右子树压入栈，这样，下次循环就能交换儿子结点的左右子树了。
void mirrorIt(TreeNode *root) {
    if (root == NULL) return;
    stack<TreeNode *> stk;
    stk.push(root);
    while (!stk.empty()) {
        TreeNode *node = stk.top();
        stk.pop();
        TreeNode *tmp = node->left;
        node->left = node->right;
        node->right = tmp;
        if (node->left) {
            stk.push(node->left);
        }
        if (node->right) {
            stk.push(node->right);
        }
    }
}

Invert Binary Tree 
其实就是剑指offer上二叉树的镜像
类似的:Symmetric Tree判断是否为镜像二叉树

Invert a binary tree.

     4
   /   \
  2     7
 / \   / \
1   3 6   9
to
     4
   /   \
  7     2
 / \   / \
9   6 3   1
Trivia:
This problem was inspired by this original tweet by Max Howell:
Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
//直接获取根节点的左右节点，然后进行交换即可。方法一直接进行交换，递归写法
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return NULL;
        TreeNode *left = root->left;
        TreeNode *right = root->right;
        root->left = invertTree(right);
        root->right = invertTree(left);
        return root;
    }
};

或者这样写：都是递归写法
class Solution {
public:
//直接获取根节点的左右节点，然后进行交换即可。方法一直接进行交换
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return NULL;
        TreeNode *tmp = root->left;
        root->left = root->right;
        root->right = tmp;
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};

class Solution {
public:
//非递归写法：
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return NULL;
        stack<TreeNode *> stk;
        stk.push(root);
        while (!stk.empty()) {
            TreeNode *node = stk.top();
            stk.pop();
            TreeNode *tmp = node->left;
            node->left = node->right;
            node->right = tmp;
            if (node->left) stk.push(node->left);
            if (node->right) stk.push(node->right);
        }
        return root;
    }
};
/*
用辅助栈模拟递归，把树的头结点放入栈，只要栈不为空，弹出栈的栈顶结点，交换它的左右子数，如果它有左子树，就把左子树压入栈，如果它有右子树，就把右子树压入栈，这样，下次循环就能交换儿子结点的左右子树了。
*/


Mirror of n-ary Tree
n插树的镜像（即树的结点有多个子结点）
http://www.geeksforgeeks.org/mirror-of-n-ary-tree/

Given a Tree where every node contains variable number of children, convert the tree to its mirror. Below diagram shows an example.

Node of tree is represented as a key and a variable sized array of children pointers. The idea is similar to mirror of Binary Tree. For every node, we first recur for all of its children and then reverse array of children pointers. We can also do these steps in other way, i.e., reverse array of children pointers first and then recur for children.

struct TreeNode {
    int val;
    vector<TreeNode *> child;
};
void mirrorTree(TreeNode *root) {  // convert a tree to its mirror
    if (root == NULL) return;
    int n = root->child.size();  // Number of children of root
    if (n < 2) return;    //If number of child is 1 or 2, we do not need do anything
    for (int i = 0; i < n; ++i) {
        mirrorTree(root->child[i]);  //call mirror for each child
    }                      // Reverse vector (variable sized array) of child pointers
    reverse(root->child.begin(), root->child.end()); 
}
void printNodeLevelWise(TreeNode *root) {
    if (root == NULL) return;
    queue<TreeNode *> q;
    q.push(root);
    while (!q.empty()) {  //level order traversal, two loops are used to make sure 
        int n = q.size();  //that different levels are printed in different lines
        while (n > 0) {
            TreeNode *p = q.front();
            q.pop();
            cout << p->val << " ";
            for (int i = 0; i < p->child.size(); ++i) {
                q.push(p->child[i]);
            }
            n--;
        }
        cout << endl;  // Separator between levels
    }
}

// Driver program
int main()
{
    /*   Let us create below tree
    *              10
    *        /   /    \   \
    *        2  34    56   100
    *                 |   /  | \
    *                 1   7  8  9
    */
    Node *root = newNode(10);
    (root->child).push_back(newNode(2));
    (root->child).push_back(newNode(34));
    (root->child).push_back(newNode(56));
    (root->child).push_back(newNode(100));
    (root->child[2]->child).push_back(newNode(1));
    (root->child[3]->child).push_back(newNode(7));
    (root->child[3]->child).push_back(newNode(8));
    (root->child[3]->child).push_back(newNode(9));
 
    cout << "Level order traversal Before Mirroring\n";
    printNodeLevelWise(root);
 
    mirrorTree(root);
 
    cout << "\nLevel order traversal After Mirroring\n";
    printNodeLevelWise(root);
 
    return 0;
}

Output:

Level order traversal Before Mirroring
10 
2 34 56 100 
1 7 8 9 

Level order traversal After Mirroring
10 
100 56 34 2 
9 8 7 1


