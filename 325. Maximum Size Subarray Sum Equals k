[LeetCode] Maximum Size Subarray Sum Equals k 最大子数组之和为k

Maximum Size Subarray Sum Equals k

Given an array nums and a target value k, find the maximum length of a subarray that sums to k. 
If there isn't one, return 0 instead.

Example 1:

Given nums = [1, -1, 5, -2, 3], k = 3,
return 4. (because the subarray [1, -1, 5, -2] sums to 3 and is the longest)

Example 2:

Given nums = [-2, -1, 2, 1], k = 1,
return 2. (because the subarray [-1, 2] sums to 1 and is the longest)

Follow Up:
Can you do it in O(n) time?


class Solution {
public:
    int maxSubArrayLen(vector<int>& nums, int k) {
        unordered_map<int, int> sums;
        int cur_sum = 0;
        int max_len = 0;
        for (int i = 0; i < nums.size(); i++) {
            cur_sum += nums[i];
            if (cur_sum == k) {
                max_len = i + 1;
            } else if (sums.find(cur_sum - k) != sums.end()) {
                max_len = max(max_len, i - sums[cur_sum - k]);
            }
            if (sums.find(cur_sum) == sums.end()) {
                sums[cur_sum] = i;
            }            
        }
        return max_len;
    }
};

http://www.cnblogs.com/grandyang/p/5336668.html
直接用一个变量sum边累加边处理，哈希表只要保存第一个出现该累积和的位置，后面再出现直接跳过，这样算下来就是最长的子数组
其实和上面是一样的
class Solution {
public:
    int maxSubArrayLen(vector<int>& nums, int k) {
        int sum = 0, res = 0;
        unordered_map<int, int> m;
        for (int i = 0; i < nums.size(); ++i) {
            sum += nums[i];
            if (sum == k) res = i + 1;
            else if (m.count(sum - k)) res = max(res, i - m[sum - k]);
            if (!m.count(sum)) m[sum] = i;
        }
        return res;
    }
};

/*
参考:
https://leetcode.com/discuss/77873/o-n-c-solution-using-unordered_map

https://leetcode.com/discuss/77879/o-n-super-clean-9-line-java-solution-with-hashmap

http://www.cnblogs.com/hygeia/p/5123140.html

The HashMap stores the sum of all elements before index i as key, and i as value. 
For each i, check not only the current sum but also (currentSum - previousSum) to see 
if there is any that equals k, and update max length.


Nice solution! Only one question, if sum == k, we do not need to check the second one cause 
i+1 must be larger, right? So, if (sum == k) max = i + 1; else if (map.containsKey(sum - k)) 
max = Math.max(max, i - map.get(sum - k));

Yes you are right! I should add an "else" to jump over. Thanks.

//java代码，和上面的c++代码其实一样的：
public int maxSubArrayLen(int[] nums, int k) {
    int sum = 0, max = 0;
    HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
    for (int i = 0; i < nums.length; i++) {
        sum = sum + nums[i];
        if (sum == k) max = i + 1;
        else if (map.containsKey(sum - k)) max = Math.max(max, i - map.get(sum - k));
        if (!map.containsKey(sum)) map.put(sum, i);
    }
    return max;
}

are u sure this is O(n) solution? cause the hash map method - containsKey() will always consume 
time which is related to the array. In worst case, i think it is not O(n).

On average it's o(1). Please see this: 
http://stackoverflow.com/questions/8923251/what-is-the-time-complexity-of-hashmap-containskey-in-java

I think the worst case rarely happens. Thanks for pointing out anyway.
*/
