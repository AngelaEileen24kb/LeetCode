Reorder List 

Given a singly linked list L: L0→L1→…→Ln-1→Ln,
reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…

You must do this in-place without altering the nodes' values.

For example,
Given {1,2,3,4}, reorder it to {1,4,2,3}.

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */

思路: http://www.geeksforgeeks.org/rearrange-a-given-linked-list-in-place/

1) Find the middle point using tortoise and hare method.
2) Split the linked list in two halves using found middle point in step 1.
3) Reverse the second half.
4) Do alternate merge of first and second halves. 
Time Complexity of this solution is O(n).

时间复杂度:O(n)
class Solution { leetcode AC代码:
public:
    void reorderList(ListNode* head) {
        if (head == NULL || head->next == NULL) return;
        ListNode *slow = head, *fast = head;
        while (fast->next && fast->next->next) {
            fast = fast->next->next;  //这种写法不管结点个数是奇数还是偶数，都适用
            slow = slow->next;
        }
        ListNode *mid = slow, *cur = slow->next;  //find middle point
        while (cur->next) {      //reverse the second half 
            ListNode *move = cur->next;
            cur->next = move->next;
            move->next = mid->next;
            mid->next = move;
        }
        cur = head;       //Do alternate merge of first and second halves. 
        while (cur != mid && mid->next) {
            ListNode *move = mid->next;
            mid->next = move->next;
            move->next = cur->next;
            cur->next = move;
            cur = cur->next->next;
        }
    }
};

原始写法:不用看了
class Solution {
public:
    void reorderList(ListNode *head) {
        if (!head || !head->next) {
            return;
        }
        ListNode *slow = head, *fast = head->next->next;
        while (fast && fast->next) {
            fast = fast->next->next;
            slow = slow->next;
        }
        if (fast) {
            slow = slow->next;
        }
        ListNode *mid = slow, *cur = slow->next;
        while (cur->next) {
            ListNode *move = cur->next;
            cur->next = move->next;
            move->next = mid->next;
            mid->next = move;
        }
        cur = head;
        while (cur != mid && mid->next) {
            ListNode *move = mid->next;
            mid->next = move->next;
            move->next = cur->next;
            cur->next = move;
            cur = cur->next->next;
        }
    }
};
