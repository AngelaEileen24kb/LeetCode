322. Coin Change 硬币找零/美分的组成

You are given coins of different denominations and a total amount of money amount. 
Write a function to compute the fewest number of coins that you need to make up that amount. 
If that amount of money cannot be made up by any combination of the coins, return -1.

Example 1:
coins = [1, 2, 5], amount = 11
return 3 (11 = 5 + 5 + 1)

Example 2:
coins = [2], amount = 3
return -1.

Note:
You may assume that you have an infinite number of each kind of coin.

Credits:
Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.


O(n*amount) time O(amount) space DP solution

class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, amount + 1);
        dp[0] = 0;
        for (int i = 1; i <= amount; ++i) {
            for (int j = 0; j < coins.size(); ++j) {
                if (i >= coins[j]) {
                    dp[i] = min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
};
/*
参考：
https://leetcode.com/discuss/76194/c-o-n-amount-time-o-amount-space-dp-solution

*/

还可以这么写，这种写法是最好的:
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for (auto coin : coins) {
            for (int i = coin; i <= amount; ++i) {
                if (dp[i - coin] != INT_MAX) {
                    dp[i] = min(dp[i], dp[i - coin] + 1);
                }
            }
        }
        return dp[amount] == INT_MAX ? -1 : dp[amount];
    }
};
/*
参考：
http://www.cnblogs.com/easonliu/p/5082283.html

https://leetcode.com/discuss/76194/c-o-n-amount-time-o-amount-space-dp-solution

Time: O(n*amount) , 这里的amount其实是amount - n,n为coins的种类数 
Space: O(amount), 这里的amount其实是amount - n,n为coins的种类数 
*/


[LeetCode] Coin Change 硬币找零
http://www.cnblogs.com/grandyang/p/5138186.html

You are given coins of different denominations and a total amount of money amount. 
Write a function to compute the fewest number of coins that you need to make up that amount. 
If that amount of money cannot be made up by any combination of the coins, return -1.

Example 1:
coins = [1, 2, 5], amount = 11
return 3 (11 = 5 + 5 + 1)

Example 2:
coins = [2], amount = 3
return -1.

Note:
You may assume that you have an infinite number of each kind of coin.

Credits:
Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.

http://www.cnblogs.com/grandyang/p/5138186.html

这道题给我们了一些可用的硬币值，又给了一个钱数，问我们最小能用几个硬币来找零。根据题目中的例子可知，不是每次都会给全1,2,5的硬币，
有时候没有1分硬币，那么有的钱数就没法找零，需要返回-1。这道题跟CareerCup上的那道9.8 Represent N Cents 美分的组成有些类似，
那道题给全了所有的美分，25,10,5,1，然后给我们一个钱数，问我们所有能够找零的方法，而这道题只让我们求出最小的那种，对于求极值问题，
我们还是主要考虑动态规划Dynamic Programming来做，我们维护一个一维动态数组dp，其中dp[i]表示钱数为i时的最小硬币数的找零，递推式为：

dp[i] = min(dp[i], dp[i - coins[j]] + 1);
其中coins[j]为第j个硬币，而i - coins[j]为钱数i减去其中一个硬币的值，剩余的钱数在dp数组中找到值，然后加1和当前dp数组中的值做比较，
取较小的那个更新dp数组。先来看迭代的写法如下所示：

法1:
// Non-recursion
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, amount + 1);
        dp[0] = 0;
        for (int i = 1; i <= amount; ++i) {
            for (int j = 0; j < coins.size(); ++j) {
                if (coins[j] <= i) {
                    dp[i] = min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
};
再来看递归的写法，思路都一样，仅仅是写法有些区别：
// Recursion
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        return coinChangeDFS(coins, amount, dp);
    }
    int coinChangeDFS(vector<int> &coins, int amount, vector<int> &dp) {
        if (amount < 0) return - 1;
        if (dp[amount] != INT_MAX) return dp[amount];
        for (int i = 0; i < coins.size(); ++i) {
            int tmp = coinChangeDFS(coins, amount - coins[i], dp);
            if (tmp >= 0) dp[amount] = min(dp[amount], tmp + 1);
        }
        return dp[amount] = dp[amount] == INT_MAX ? -1 : dp[amount];
    }
};
最后来看一种使用哈希表的递归解法：

// Recursion 
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        unordered_map<int, int> dp;
        dp[0] = 0;
        return coinChangeDFS(coins, amount, dp);
    }
    int coinChangeDFS(vector<int> &coins, int amount, unordered_map<int, int> &dp) {
        if (amount < 0) return - 1;
        if (dp.find(amount) != dp.end()) return dp[amount];
        int cur = INT_MAX;
        for (int i = 0; i < coins.size(); ++i) {
            int tmp = coinChangeDFS(coins, amount - coins[i], dp);
            if (tmp >= 0) cur = min(cur, tmp + 1);
        }
        return dp[amount] = cur == INT_MAX ? -1 : cur;
    }
};

类似题目：

9.8 Represent N Cents 美分的组成

[CareerCup] 9.8 Represent N Cents 美分的组成
 
http://www.cnblogs.com/grandyang/p/4840713.html

9.8 Given an infinite number of quarters (25 cents), dimes (10 cents), nickels (5 cents) and pennies (1 cent), 
write code to calculate the number of ways of representing n cents.

 

这道题给定一个钱数，让我们求用quarter，dime，nickle和penny来表示的方法总和，很明显还是要用递归来做。比如我们有50美分，那么

makeChange(50) =

　　makeChange(50 using 0 quarter) +

　　makeChange(50 using 1 quarter) +

　　makeChange(50 using 2 quarters)

 

而其中第一个makeChange(50 using 0 quarter)又可以拆分为：

makeChange(50 using 0 quarter) =

　　makeChange(50 using 0 quarter， 0 dimes) + 

　　makeChange(50 using 0 quarter， 1 dimes) + 

　　makeChange(50 using 0 quarter， 2 dimes) + 

　　makeChange(50 using 0 quarter， 3 dimes) + 

　　makeChange(50 using 0 quarter， 4 dimes) + 

　　makeChange(50 using 0 quarter， 5 dimes)

 

而这里面的每项又可以继续往下拆成nickle和penny，整体是一个树形结构，计算顺序是从最底层开始，也就是给定的钱数都是由penny组成的情况
慢慢往回递归，加一个nickle，加两个nickle，再到加dime和quarter，参见代码如下：

法1:
class Solution {
public:
    int makeChange(int n) {
        vector<int> denoms = {25, 10, 5, 1};
        return makeChange(n, denoms, 0);
    }
    int makeChange(int amount, vector<int> denoms, int idx) {
        if (idx >= denoms.size() - 1) return 1;
        int val = denoms[idx], res = 0;
        for (int i = 0; i * val <= amount; ++i) {
            int rem = amount - i * val;
            res += makeChange(rem, denoms, idx + 1);
        }
        return res;
    }
};
上述代码虽然正确但是效率一般，因为存在大量的重复计算，我们可以用哈希表来保存计算过程中的结果，下次遇到相同结果时，
直接从哈希表中取出来即可，参见代码如下：
法2:
class Solution {
public:
    int makeChange(int n) {
        vector<int> denoms = {25, 10, 5, 1};
        vector<vector<int> > m(n + 1, vector<int>(denoms.size()));
        return makeChange(n, denoms, 0, m);
    }
    int makeChange(int amount, vector<int> denoms, int idx, vector<vector<int> > &m) {
        if (m[amount][idx] > 0) return m[amount][idx];
        if (idx >= denoms.size() - 1) return 1;
        int val = denoms[idx], res = 0;
        for (int i = 0; i * val <= amount; ++i) {
            int rem = amount - i * val;
            res += makeChange(rem, denoms, idx + 1, m);
        }
        m[amount][idx] = res;
        return res;
    }
};

